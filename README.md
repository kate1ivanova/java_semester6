# java_semester6
Assignment 1. Создать класс контейнер, позволяющий хранить произвольное количество целых чисел. Использование встроенных коллекций запрещено.  Задание можно реализовать с помощью массива или связанного списка. Контейнер должен позволять добавлять, извлекать, удалять элементы

Assignment 2. Выражение может содержать числа, знаки операций, скобки. В случае, если выражение записано корректно, вычислить значение, в противном случае — вывести сообщение об ошибке.
Дополнительно приветствуется поддержка имен переменных и различных функций. В случае, если есть переменные, их значения нужно запросить у пользователя (для каждой из них — по одному разу).

Assignment 3. Сравнить производительность ArrayList и LinkedList. Необходимо написать код, который бы вызывал основные методы коллекций определенное(1000 или 2000, или любое другое) количество раз. При этом должно засекаться время. Минимально необходимо протестировать методы:add, delete, get. После этого вывести таблицу с результатами(метод, сколько раз выполнялся, время выполнения).

Assignment 4. век с полями 
ID
Имя
Пол
Подразделение(Сущность подразделение)
Зарплата
Дата рождения
Подразделение с полями:
ID(генерится в програме)
Название
Дан CSV файл(архив с ним есть внутри задания), который содержит в себе информацию о людях. Нужно считать данные о людях из этого файла в список
В этой задаче нужно пользоваться встроенными Java  коллекциями
Для работы с CSV файлом использовать библиотеку opencsv

Assignment 5.
Рефлексия (di)
Создать аннотацию @AutoInjectable
Разобраться(поискать в Google) с классом Properties
Создать класс Injector в котором был бы параметризированный метод inject, который принимал бы в
качестве параметра объект любого класса и, используя механизмы рефлексии осуществлял поиск полей, помеченных
этой аннотацией(в качестве типа поля используются некоторый интерфейс), и осуществлял бы инициализацию этих полей
экземплярами классов, которые указаны в качестве реализации соответствующего интерфейса в некотором файле настроек(properites)
Пример:
У нас есть несколько интерфейсов и несколько классов, реализующих эти интерфейсы:

interface SomeInterface{
  public void doSomething();
}
interface SomeOtherInterface{
  public void doSomeOther();
}
class SomeImpl implements SomeInterface{
  public void doSomething(){ println(“A”);}
}
class OtherImpl implements SomeInterface{
  public void doSomething(){ println(“B”);}
}
class SODoer implements SomeOtherInterface{
  public void doSomething(){ println(“C”);}
}
class SomeBean{
  @AutoInjectable
  private SomeInterface field1;
  @AutoInjectable
  private SomeOtherInterface field2;

  public void foo(){
    field1.doSomething();
    field2.doSomething();
  }
}
Ваша задача написать класс Injector, который бы осуществлял внедрение зависимостей в любой объект ,
который содержит поля, помеченные нашей аннотацией. Т.е. некоторый метод этого класса, принимал бы произвольный объект,
исследовал бы существующие в нем поля, и смотрел, аннотированы ли они нужной аннотацией.
Если да, то тогда он бы смотрел тип этого поля и искал бы реализацию в файле properties:

Пример файла:

somepackage.SomeInterface=somePackage.SomeImpl
somepackage.SomeOtherInterface=somepackage.SODoer
После этого, он создавал бы экземпляр нужного класса и записывал ссылку на этот экземпляр в нужное поле.
Т.е. для нашего примера метод inject должен в поле field1 записать экземпляр класса SomeImpl, а в поле field2 класса SODoer.
Теперь, инициализация объектов класса SomeBean будет выглядеть следующим образом:

SomeBean sb =(new Injector()).inject(new SomeBean());
sb.foo();
И теперь никаких ошибок быть не должно, а на экран должно вывестись AC
Если же мы поменяем в файле properties строчку

somepackage.SomeInterface=somePackage.SomeImpl
на

somepackage.SomeInterface=somePackage.OtherImpl
Должно вывестись BC
